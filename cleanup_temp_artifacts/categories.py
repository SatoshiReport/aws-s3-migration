"""
Category definitions and matcher functions for cleanup_temp_artifacts.

Each category represents a type of temporary or cache artifact that can be cleaned up.
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Callable

Matcher = Callable[[Path, bool], bool]


@dataclass(frozen=True)
class Category:
    """Represents a category of files to cleanup with matching rules."""

    name: str
    description: str
    matcher: Matcher
    prune: bool


def _match_python_bytecode(path: Path, is_dir: bool) -> bool:
    return is_dir and path.name == "__pycache__"


def _match_python_test_cache(path: Path, is_dir: bool) -> bool:
    return is_dir and path.name in {".pytest_cache", ".mypy_cache", ".hypothesis"}


def _match_python_tox_cache(path: Path, is_dir: bool) -> bool:
    return is_dir and path.name in {".tox", ".nox", ".ruff_cache"}


def _match_generic_dot_cache(path: Path, is_dir: bool) -> bool:
    return is_dir and path.name == ".cache"


def _match_vscode_remote(path: Path, is_dir: bool) -> bool:
    return (
        is_dir
        and ".vscode-server" in path.parts
        and path.name in {"node_modules", "extensions", "server"}
    )


def _match_go_module_cache(path: Path, is_dir: bool) -> bool:
    if not is_dir or path.name != "cache":
        return False
    parts = ("go", "pkg", "mod", "cache")
    return path.parts[-len(parts) :] == parts if len(path.parts) >= len(parts) else False


def _match_maven_cache(path: Path, is_dir: bool) -> bool:
    if not is_dir or not path.name.startswith(".cache"):
        return False
    if ".m2" not in path.parts:
        return False
    parts = (".m2", "repository", path.name)
    return path.parts[-len(parts) :] == parts if len(path.parts) >= len(parts) else False


def _match_npm_cache(path: Path, is_dir: bool) -> bool:
    if not is_dir:
        return False
    return (path.name == "_cacache" and path.parent.name == ".npm") or (
        path.name == "cache" and path.parent.name == ".yarn"
    )


def _create_category_list() -> list[Category]:
    """Create list of all category definitions."""
    return [
        Category(
            name="python-bytecode",
            description="Python __pycache__ directories generated by the interpreter.",
            matcher=_match_python_bytecode,
            prune=True,
        ),
        Category(
            name="python-test-cache",
            description=".pytest_cache / .mypy_cache / .hypothesis artifacts from test runs.",
            matcher=_match_python_test_cache,
            prune=True,
        ),
        Category(
            name="python-tox-cache",
            description="Python tooling environments such as .tox, .nox, and .ruff_cache.",
            matcher=_match_python_tox_cache,
            prune=True,
        ),
        Category(
            name="generic-dot-cache",
            description="Generic .cache directories (pip wheels, IDE caches, etc.).",
            matcher=_match_generic_dot_cache,
            prune=True,
        ),
        Category(
            name="vscode-remote",
            description="VS Code Remote server bundles (node_modules, extensions, server caches).",
            matcher=_match_vscode_remote,
            prune=True,
        ),
        Category(
            name="go-module-cache",
            description="Go module download cache under go/pkg/mod/cache.",
            matcher=_match_go_module_cache,
            prune=True,
        ),
        Category(
            name="maven-cache",
            description="Maven .m2/repository/.cache directories.",
            matcher=_match_maven_cache,
            prune=True,
        ),
        Category(
            name="npm-cache",
            description="npm/yarn cache folders such as .npm/_cacache and .yarn/cache.",
            matcher=_match_npm_cache,
            prune=True,
        ),
    ]


def build_categories() -> dict[str, Category]:
    """Return the static set of cleanup categories."""
    categories = _create_category_list()
    return {c.name: c for c in categories}
